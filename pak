#!/bin/bash
# A text-based packer that bundles files (with metadata) into a single archive.
# Output is designed to be easily parsed text, suitable for LLMs.
#
# Version: 1.5.1
#
# Changes in this version:
#  - Fixed Bash syntax errors in 'pack' function related to 'find' command array construction.
#  - Added --ext option to --pack mode to specify included file extensions when recursing into directories.
#  - Unified hidden file/directory exclusion logic for direct file arguments to match find behavior.
#  - Added regex pattern support with --include-regex and --exclude-regex
#  - Added archive verification with --verify
#  - Added extraction to specified directory with --outdir
#  - Added selective extraction with --include and --exclude options
#  - Support for multiple include/exclude patterns
#  - Improved unpack performance on network filesystems (like Google Drive in WSL2)
#  - Added better debug messages during unpacking
#  - Included local file caching for archive during unpacking
#  - Modified --ls output format to "filepath/filename and Size: XXX".
#  - Modified --ls output to show only Path and Size (removed Lines).
#  - Uses a unique UUID in markers to prevent collision with file content.
#  - Unpacking writes each line followed by a newline. Note that this might
#    alter original file line endings (\n vs \r\n) and add a newline to the
#    last line of a file if the original didn't have one. For LLM consumption,
#    this line-by-line representation is typically sufficient.
#  - Added UUID marker prefix to the archive header.
#  - Requires `uuidgen` command to be available for packing.
#  - Improved reading of the archive in ls/unpack modes to handle the UUID header.
#  - Fixed a potential issue where the last line of the archive might be missed
#    in unpack_archive if it didn't end with a newline.
#
# Usage:
#   Pack (default mode):
#       pak [--pack] [--ext .ext1 .ext2 ...] <files/directories> > archive.pak
#   List:
#       pak --ls <archive file>  # Outputs "filepath/filename and Size: XXX"
#   Unpack:
#       pak --unpack <archive file> [--include pattern] [--exclude pattern] [--include-regex pattern] [--exclude-regex pattern] [--outdir dir]
#   Verify:
#       pak --verify <archive file>
#   Version:
#       pak --version
#
# Examples:
#   Pack only Python and Markdown files from 'src' directory and 'main.py':
#       pak --pack --ext .py .md src main.py > archive.pak
#   Extract only Python files:
#       pak --unpack archive.pak --include "*.py"
#   Extract all except text files:
#       pak --unpack archive.pak --exclude "*.txt"
#   Extract files matching regex:
#       pak --unpack archive.pak --include-regex "NPC\.[a-z]+\..*\.txt"
#   Extract to specific directory:
#       pak --unpack archive.pak --outdir /path/to/extract
#   Multiple patterns:
#       pak --unpack archive.pak --include "*.py" --include "*.md" --exclude "test_*.py"

# Version information
VERSION="1.5.1" # Incremented for bug fix

# Check for uuidgen dependency (only needed for packing)
check_uuidgen() {
    if ! command -v uuidgen &> /dev/null; then
        echo "Error: 'uuidgen' command not found." >&2
        echo "Please install it (e.g., on Debian/Ubuntu: sudo apt-get install uuid-runtime)." >&2
        exit 1
    fi
}

# Marker prefixes used to delimit sections in the archive
PAK_UUID_LINE_PREFIX="__PAK_UUID__:"
PAK_FILE_START_PREFIX="__PAK_FILE_"
PAK_DATA_START_PREFIX="__PAK_DATA_"
PAK_DATA_END_PREFIX="__PAK_DATA_" # Suffix will be _END__<UUID>__

# Function to define the actual start/end markers using a specific UUID
define_markers() {
    local uuid="$1"
    PAK_FILE_START="${PAK_FILE_START_PREFIX}${uuid}_START__"
    PAK_DATA_START="${PAK_DATA_START_PREFIX}${uuid}_START__"
    PAK_DATA_END="${PAK_DATA_END_PREFIX}${uuid}_END__"
}

# Function to pack a single file into the archive format.
pack_file() {
    local file="$1"
    local uuid="$2"
    define_markers "$uuid" # Define markers using the current archive's UUID

    local size lines
    if ! size=$(stat -c%s "$file" 2>/dev/null); then
        echo "Warning: Could not get size for '$file'. Skipping." >&2
        return
    fi
    if ! lines=$(wc -l < "$file" 2>/dev/null); then
         lines="N/A"
    fi

    echo "$PAK_FILE_START"
    echo "Path: $file"
    echo "Size: $size"
    echo "Lines: $lines"
    echo "$PAK_DATA_START"
    cat "$file"
    if [ "$(tail -c1 "$file" | wc -l)" -eq 0 ]; then
        echo # Add a newline
    fi
    echo "$PAK_DATA_END"
}

# Pack mode: process each file/directory argument and output the archive to stdout.
pack() {
    check_uuidgen

    local PACK_INCLUDE_EXTENSIONS=()
    local FILES_AND_DIRS_TO_PACK=()

    # Parse --ext arguments and file/directory paths
    while [ "$#" -gt 0 ]; do
        case "$1" in
            --ext)
                shift # remove --ext
                if [ "$#" -eq 0 ] || [[ "$1" == --* ]]; then
                    echo "Error: --ext requires at least one extension argument (e.g., .py .txt)" >&2
                    echo "Usage: $0 --pack [--ext .ext1 .ext2 ...] <files/directories>" >&2
                    exit 1
                fi
                while [ "$#" -gt 0 ] && [[ "$1" != --* ]]; do
                    PACK_INCLUDE_EXTENSIONS+=("*$1") # Store as wildcard pattern, e.g., .py becomes *.py
                    shift
                done
                ;;
            *) # Assumed to be a file or directory path
                FILES_AND_DIRS_TO_PACK+=("$1")
                shift
                ;;
        esac
    done

    if [ "${#FILES_AND_DIRS_TO_PACK[@]}" -eq 0 ]; then
        echo "Usage: $0 --pack [--ext .ext1 .ext2 ...] <files/directories>" >&2
        echo "Error: No files or directories specified for packing." >&2
        exit 1
    fi

    local archive_uuid
    archive_uuid=$(uuidgen)
    if [ -z "$archive_uuid" ]; then
         echo "Error: Failed to generate UUID." >&2
         exit 1
    fi

    echo "${PAK_UUID_LINE_PREFIX}${archive_uuid}"
    define_markers "$archive_uuid"

    for item in "${FILES_AND_DIRS_TO_PACK[@]}"; do
        if [ -f "$item" ]; then
            local base_item
            base_item=$(basename "$item")
            if [[ "$base_item" == "poetry.lock" || "$item" == *.pak || "$item" =~ (^|/)\. ]]; then
                echo "Info: Skipping explicitly provided file '$item' (hidden, specific exclusion, or .pak)." >&2
                continue
            fi
            pack_file "$item" "$archive_uuid"
        elif [ -d "$item" ]; then
            if [[ "$item" =~ (^|/)\. && "$item" != "." && "$item" != ".." ]]; then
                echo "Info: Skipping hidden directory '$item'." >&2
                continue
            fi

            local find_cmd_parts=()
            local search_path="$item"
            
            find_cmd_parts+=("$search_path")
            find_cmd_parts+=("-mindepth" "1")

            # Directory exclusions to prune: \( -name "node_modules" -o ... \) -prune -o
            find_cmd_parts+=("(") # Start of prune group
            find_cmd_parts+=("-name" "node_modules")
            find_cmd_parts+=("-o" "-name" "__pycache__")
            find_cmd_parts+=("-o" "-name" "python")
            find_cmd_parts+=("-o" "-name" "*.dist-info")
            find_cmd_parts+=("-o" "-name" "venv")
            find_cmd_parts+=("-o" "-name" ".venv")
            find_cmd_parts+=("-o" "-name" "htmlcov")
            find_cmd_parts+=("-o" "-path" "*/.git")
            find_cmd_parts+=("-o" "-path" "*/.svn")
            find_cmd_parts+=("-o" "-path" "*/.hg")
            find_cmd_parts+=(")") # End of prune group
            find_cmd_parts+=("-prune")
            find_cmd_parts+=("-o") # OR, proceed if not pruned
            
            # Start group for file selection criteria: \( -type f ... -print0 \)
            find_cmd_parts+=("(") # Start of selection criteria group
            find_cmd_parts+=("-type" "f")
            
            # General file name/path based exclusions
            find_cmd_parts+=("!" "-name" "*.pak")
            find_cmd_parts+=("!" "-name" "poetry.lock")
            find_cmd_parts+=("!" "-path" "*/.*") # Exclude hidden files/dirs

            # Add extension filtering if PACK_INCLUDE_EXTENSIONS is not empty
            if [ "${#PACK_INCLUDE_EXTENSIONS[@]}" -gt 0 ]; then
                find_cmd_parts+=("(") # Start OR group for extensions
                local first_ext=true
                for ext_pattern in "${PACK_INCLUDE_EXTENSIONS[@]}"; do
                    if ! $first_ext; then
                        find_cmd_parts+=("-o")
                    fi
                    find_cmd_parts+=("-name" "$ext_pattern")
                    first_ext=false
                done
                find_cmd_parts+=(")") # End OR group for extensions
            fi

            find_cmd_parts+=("-print0") # Action
            find_cmd_parts+=(")") # End of selection criteria group
            
            # For debugging the find command:
            # echo "Debug: find ${find_cmd_parts[@]}" >&2
            
            find "${find_cmd_parts[@]}" | while IFS= read -r -d $'\0' file; do
                 pack_file "$file" "$archive_uuid"
            done
        else
            echo "Warning: '$item' is not a file or directory. Skipped." >&2
        fi
    done
}

# List mode: display archive metadata
list_archive() {
    local archive="$1"
    if [ ! -f "$archive" ]; then
        echo "Archive file not found: $archive" >&2
        exit 1
    fi

    local first_line
    if ! read -r first_line < "$archive"; then
        echo "Error: Could not read archive file: $archive" >&2
        exit 1
    fi

    local archive_uuid=""
    if [[ "$first_line" == "${PAK_UUID_LINE_PREFIX}"* ]]; then
        archive_uuid="${first_line#${PAK_UUID_LINE_PREFIX}}"
    else
        echo "Warning: Archive file '${archive}' does not start with a UUID header. Attempting to parse with default markers (may fail)." >&2
        define_markers "LEGACY_PLACEHOLDER"
    fi

    if [ -n "$archive_uuid" ]; then
         define_markers "$archive_uuid"
         tail -n +2 "$archive" | awk -v FILE_START="$PAK_FILE_START" -v DATA_START="$PAK_DATA_START" '
         $0 == FILE_START { header = 1; next }
         header && /^Path: / { path = substr($0, index($0," ")+1); next }
         header && /^Size: / { size = substr($0, index($0," ")+1); next }
         header && /^Lines: / { next }
         header && $0 == DATA_START {
             printf "%s and Size: %s\n", path, size;
             header = 0;
             next;
         }
         '
    else
         awk -v FILE_START="$PAK_FILE_START" -v DATA_START="$PAK_DATA_START" '
         $0 == FILE_START { header = 1; next }
         header && /^Path: / { path = substr($0, index($0," ")+1); next }
         header && /^Size: / { size = substr($0, index($0," ")+1); next }
         header && /^Lines: / { next }
         header && $0 == DATA_START {
             printf "%s and Size: %s\n", path, size;
             header = 0;
             next;
         }
         ' "$archive"
    fi
}

# Function to check if a file path matches any glob pattern in an array
matches_any_glob_pattern() {
    local file_path="$1"
    shift
    local patterns=("$@")
    
    for pattern in "${patterns[@]}"; do
        if [[ "$file_path" == $pattern ]]; then
            return 0 # Match found
        fi
    done
    return 1 # No match
}

# Function to check if a file path matches any regex pattern in an array
matches_any_regex_pattern() {
    local file_path="$1"
    shift
    local patterns=("$@")
    
    for pattern in "${patterns[@]}"; do
        if [[ "$file_path" =~ $pattern ]]; then
            return 0 # Match found
        fi
    done
    return 1 # No match
}

# Function to verify the integrity of an archive
verify_archive() {
    local archive="$1"
    echo "Verifying archive '$archive'..."
    
    if [ ! -f "$archive" ]; then
        echo "Error: Archive file not found: $archive" >&2
        exit 1
    fi

    local temp_dir="/tmp/pak_temp_verify_$(date +%s%N)"
    local temp_archive="${temp_dir}/$(basename "$archive")"
    
    mkdir -p "$temp_dir"
    cp "$archive" "$temp_archive"
    
    if [ ! -f "$temp_archive" ]; then
        echo "Error in temporary copy. Using original." >&2
        temp_archive="$archive"
    fi

    local first_line
    if ! read -r first_line < "$temp_archive"; then
        echo "Error: Cannot read archive file: $temp_archive" >&2
        rm -rf "$temp_dir"
        exit 1
    fi

    local archive_uuid=""
    if [[ "$first_line" == "${PAK_UUID_LINE_PREFIX}"* ]]; then
        archive_uuid="${first_line#${PAK_UUID_LINE_PREFIX}}"
    else
        echo "Error: Archive does not start with a valid UUID header." >&2
        rm -rf "$temp_dir"
        exit 1
    fi

    define_markers "$archive_uuid"

    local total_files=0
    local valid_files=0
    local invalid_files=0 
    local current_state="INIT" 
    local current_file_path_meta=""
    local current_file_size_meta=""
    local error_found=false
    
    mapfile -t all_lines < <(tail -n +2 "$temp_archive")
    
    for line_idx in "${!all_lines[@]}"; do
        local line="${all_lines[$line_idx]}"
        case "$current_state" in
            "INIT")
                if [[ "$line" == "$PAK_FILE_START" ]]; then
                    current_state="HEADER"
                    current_file_path_meta=""
                    current_file_size_meta=""
                    total_files=$((total_files + 1))
                elif [ -n "$line" ]; then 
                    echo "Error (L$((line_idx+2))): Unexpected line in INIT state: '$line'" >&2
                    error_found=true; break
                fi
                ;;
            "HEADER")
                if [[ "$line" == "Path: "* ]]; then
                    current_file_path_meta="${line#Path: }"
                elif [[ "$line" == "Size: "* ]]; then
                    current_file_size_meta="${line#Size: }"
                elif [[ "$line" == "Lines: "* ]]; then
                    : 
                elif [[ "$line" == "$PAK_DATA_START" ]]; then
                    if [ -z "$current_file_path_meta" ] || [ -z "$current_file_size_meta" ]; then
                        echo "Error (L$((line_idx+2))): Incomplete metadata before DATA_START (Path: '$current_file_path_meta', Size: '$current_file_size_meta')" >&2
                        error_found=true 
                    fi
                    current_state="DATA"
                elif [ -n "$line" ]; then 
                    echo "Error (L$((line_idx+2))): Unrecognized header line or unexpected content: '$line'" >&2
                    error_found=true; 
                fi
                ;;
            "DATA")
                if [[ "$line" == "$PAK_DATA_END" ]]; then
                    current_state="INIT"
                    if ! $error_found || [ -n "$current_file_path_meta" ]; then 
                         valid_files=$((valid_files + 1))
                    fi
                else
                    :
                fi
                ;;
        esac
        if $error_found && [ "$invalid_files" -eq 0 ]; then 
            invalid_files=$((total_files - valid_files)) 
        fi
    done
    
    if [ "$current_state" != "INIT" ]; then
        echo "Error: Archive ends in an incomplete state ($current_state)." >&2
        error_found=true
        if [ "$invalid_files" -eq 0 ] && [ "$total_files" -gt "$valid_files" ]; then
             invalid_files=$((total_files - valid_files))
        elif [ "$total_files" -eq "$valid_files" ] && [ "$total_files" -gt 0 ]; then 
             invalid_files=1 
        elif [ "$total_files" -eq 0 ] && [ "$current_state" != "INIT" ]; then 
             : 
        fi
    fi
    
    rm -rf "$temp_dir"
    
    local actual_invalid_files=$((total_files - valid_files))

    echo "----------------------------------------"
    echo "Archive Verification Results:"
    echo "----------------------------------------"
    echo "Total file entries found: $total_files"
    echo "Structurally valid file entries: $valid_files"
    echo "Structurally invalid/incomplete entries: $actual_invalid_files"
    
    if $error_found || [ "$actual_invalid_files" -gt 0 ]; then
        echo "VERIFICATION FAILED: Errors found in the archive structure."
        return 1
    else
        echo "VERIFICATION SUCCESSFUL: Archive structure appears intact."
        return 0
    fi
}


# Unpack mode: read the archive and recreate files/directories.
unpack_archive() {
    local archive="$1"
    local outdir="${2:-.}"
    
    if [ ! -f "$archive" ]; then
        echo "Archive file not found: $archive" >&2
        exit 1
    fi
    
    if [ ! -d "$outdir" ]; then
        mkdir -p "$outdir"
        if [ $? -ne 0 ]; then
            echo "Error: Cannot create output directory '$outdir'" >&2
            exit 1
        fi
    fi

    local temp_dir="/tmp/pak_temp_unpack_$(date +%s%N)"
    local temp_archive="${temp_dir}/$(basename "$archive")"
    
    mkdir -p "$temp_dir"
    cp "$archive" "$temp_archive"
    
    if [ ! -f "$temp_archive" ]; then
        echo "Error in temporary copy. Using original." >&2
        temp_archive="$archive"
    fi

    local first_line
    if ! read -r first_line < "$temp_archive"; then
        echo "Error: Could not read archive file: $temp_archive" >&2
        rm -rf "$temp_dir"
        exit 1
    fi

    local archive_uuid=""
    if [[ "$first_line" == "${PAK_UUID_LINE_PREFIX}"* ]]; then
        archive_uuid="${first_line#${PAK_UUID_LINE_PREFIX}}"
    else
        echo "Warning: Archive file '${temp_archive}' does not start with a UUID header. Attempting to parse with default markers (may fail)." >&2
        define_markers "LEGACY_PLACEHOLDER"
    fi

    local files_extracted=0
    local files_skipped=0

    if [ -n "$archive_uuid" ]; then
        define_markers "$archive_uuid"
        mapfile -t all_lines < <(tail -n +2 "$temp_archive")
        
        local current_file_path=""
        local in_data_section=0
        
        for line in "${all_lines[@]}"; do
            if [[ "$line" == "$PAK_FILE_START" ]]; then
                current_file_path=""
                in_data_section=0
            elif [[ "$line" == "Path:"* ]]; then
                current_file_path="${line#Path: }"
                
                local should_extract=true
                if [ ${#INCLUDE_PATTERNS[@]} -gt 0 ] || [ ${#INCLUDE_REGEX[@]} -gt 0 ]; then
                    should_extract=false 
                    if [ ${#INCLUDE_PATTERNS[@]} -gt 0 ] && matches_any_glob_pattern "$current_file_path" "${INCLUDE_PATTERNS[@]}"; then
                        should_extract=true
                    fi
                    if ! $should_extract && [ ${#INCLUDE_REGEX[@]} -gt 0 ] && matches_any_regex_pattern "$current_file_path" "${INCLUDE_REGEX[@]}"; then
                        should_extract=true
                    fi
                fi
                
                if $should_extract; then
                    if [ ${#EXCLUDE_PATTERNS[@]} -gt 0 ] && matches_any_glob_pattern "$current_file_path" "${EXCLUDE_PATTERNS[@]}"; then
                        should_extract=false
                    fi
                    if $should_extract && [ ${#EXCLUDE_REGEX[@]} -gt 0 ] && matches_any_regex_pattern "$current_file_path" "${EXCLUDE_REGEX[@]}"; then
                        should_extract=false
                    fi
                fi

                if ! $should_extract; then
                    current_file_path="__SKIP__" 
                    files_skipped=$((files_skipped + 1))
                fi
            elif [[ "$line" == "$PAK_DATA_START" ]]; then
                if [ -n "$current_file_path" ] && [ "$current_file_path" != "__SKIP__" ]; then
                    local full_output_path="${outdir}/${current_file_path}"
                    mkdir -p "$(dirname "$full_output_path")"
                    : > "$full_output_path" 
                    in_data_section=1
                else
                    in_data_section=0 
                fi
            elif [[ "$line" == "$PAK_DATA_END" ]]; then
                if [ "$in_data_section" -eq 1 ]; then
                    files_extracted=$((files_extracted + 1))
                fi
                in_data_section=0
                current_file_path="" 
            elif [ "$in_data_section" -eq 1 ]; then
                local full_output_path="${outdir}/${current_file_path}"
                printf "%s\n" "$line" >> "$full_output_path"
            fi
        done
    else
        local current_file_path=""
        local in_data_section=0
        while IFS= read -r line || [ -n "$line" ]; do 
            if [[ "$line" == "$PAK_FILE_START" ]]; then
                current_file_path=""
                in_data_section=0
            elif [[ "$line" == "Path:"* ]]; then
                current_file_path="${line#Path: }"
                local should_extract=true
                if [ ${#INCLUDE_PATTERNS[@]} -gt 0 ] || [ ${#INCLUDE_REGEX[@]} -gt 0 ]; then
                    should_extract=false 
                    if [ ${#INCLUDE_PATTERNS[@]} -gt 0 ] && matches_any_glob_pattern "$current_file_path" "${INCLUDE_PATTERNS[@]}"; then should_extract=true; fi
                    if ! $should_extract && [ ${#INCLUDE_REGEX[@]} -gt 0 ] && matches_any_regex_pattern "$current_file_path" "${INCLUDE_REGEX[@]}"; then should_extract=true; fi
                fi
                if $should_extract; then
                    if [ ${#EXCLUDE_PATTERNS[@]} -gt 0 ] && matches_any_glob_pattern "$current_file_path" "${EXCLUDE_PATTERNS[@]}"; then should_extract=false; fi
                    if $should_extract && [ ${#EXCLUDE_REGEX[@]} -gt 0 ] && matches_any_regex_pattern "$current_file_path" "${EXCLUDE_REGEX[@]}"; then should_extract=false; fi
                fi
                if ! $should_extract; then current_file_path="__SKIP__"; files_skipped=$((files_skipped + 1)); fi
            elif [[ "$line" == "$PAK_DATA_START" ]]; then
                if [ -n "$current_file_path" ] && [ "$current_file_path" != "__SKIP__" ]; then
                    local full_output_path="${outdir}/${current_file_path}"
                    mkdir -p "$(dirname "$full_output_path")"; : > "$full_output_path"; in_data_section=1
                else
                    in_data_section=0
                fi
            elif [[ "$line" == "$PAK_DATA_END" ]]; then
                if [ "$in_data_section" -eq 1 ]; then files_extracted=$((files_extracted + 1)); fi
                in_data_section=0; current_file_path=""
            elif [ "$in_data_section" -eq 1 ]; then
                local full_output_path="${outdir}/${current_file_path}"; printf "%s\n" "$line" >> "$full_output_path"
            fi
        done < "$temp_archive"
    fi
    
    rm -rf "$temp_dir"
    echo "Extraction complete. $files_extracted file(s) extracted to '$outdir'. $files_skipped file(s) skipped."
}

# --- Main Script Logic ---

INCLUDE_PATTERNS=()
EXCLUDE_PATTERNS=()
INCLUDE_REGEX=()
EXCLUDE_REGEX=()
OUTPUT_DIR="." 

if [ "$#" -eq 0 ]; then
    echo "Usage:" >&2
    echo "  Pack (default): $0 [--pack] [--ext .ext1 .ext2 ...] <files/directories> > archive.pak" >&2
    echo "  List:           $0 --ls <archive file>" >&2
    echo "  Unpack:         $0 --unpack <archive file> [--include pattern] [--exclude pattern] [--include-regex pattern] [--exclude-regex pattern] [--outdir dir]" >&2
    echo "  Verify:         $0 --verify <archive file>" >&2
    echo "  Version:        $0 --version" >&2
    echo "" >&2
    echo "Examples:" >&2
    echo "  Pack only Python and Markdown files from 'src' dir and 'main.py':" >&2
    echo "      $0 --pack --ext .py .md src main.py > archive.pak" >&2
    echo "  Extract only Python files:" >&2
    echo "      $0 --unpack archive.pak --include \"*.py\"" >&2
    echo "  Extract all except text files:" >&2
    echo "      $0 --unpack archive.pak --exclude \"*.txt\"" >&2
    echo "  Extract files matching regex:" >&2
    echo "      $0 --unpack archive.pak --include-regex \"NPC\\.[a-z]+\\..*\\.txt\"" >&2
    echo "  Extract to specific directory:" >&2
    echo "      $0 --unpack archive.pak --outdir /path/to/extract" >&2
    echo "  Multiple patterns:" >&2
    echo "      $0 --unpack archive.pak --include \"*.py\" --include \"*.md\" --exclude \"test_*.py\"" >&2
    exit 1
fi

if [[ "$1" != --* ]]; then
    set -- --pack "$@"
fi

COMMAND="$1"
shift 

case "$COMMAND" in
    --pack)
        pack "$@"
        ;;
    --ls)
        if [ -z "$1" ]; then echo "Usage: $0 --ls <archive file>" >&2; exit 1; fi
        list_archive "$1"
        ;;
    --verify)
        if [ -z "$1" ]; then echo "Usage: $0 --verify <archive file>" >&2; exit 1; fi
        verify_archive "$1"
        ;;
    --unpack)
        if [ -z "$1" ]; then echo "Usage: $0 --unpack <archive file> [options]" >&2; exit 1; fi
        ARCHIVE_FILE="$1"
        shift 
        
        while [ "$#" -gt 0 ]; do
            case "$1" in
                --include) if [ -z "$2" ]; then echo "Error: --include requires a pattern" >&2; exit 1; fi; INCLUDE_PATTERNS+=("$2"); shift 2;;
                --exclude) if [ -z "$2" ]; then echo "Error: --exclude requires a pattern" >&2; exit 1; fi; EXCLUDE_PATTERNS+=("$2"); shift 2;;
                --include-regex) if [ -z "$2" ]; then echo "Error: --include-regex requires a pattern" >&2; exit 1; fi; INCLUDE_REGEX+=("$2"); shift 2;;
                --exclude-regex) if [ -z "$2" ]; then echo "Error: --exclude-regex requires a pattern" >&2; exit 1; fi; EXCLUDE_REGEX+=("$2"); shift 2;;
                --outdir) if [ -z "$2" ]; then echo "Error: --outdir requires a directory path" >&2; exit 1; fi; OUTPUT_DIR="$2"; shift 2;;
                *) echo "Error: Unknown option '$1' for --unpack" >&2; exit 1;;
            esac
        done
        unpack_archive "$ARCHIVE_FILE" "$OUTPUT_DIR"
        ;;
    --version)
        echo "pak version $VERSION"
        ;;
    *)
        echo "Error: Unknown command or option '$COMMAND'." >&2
        echo "Usage:" >&2
        echo "  Pack (default): $0 [--pack] [--ext .ext1 .ext2 ...] <files/directories> > archive.pak" >&2
        echo "  List:           $0 --ls <archive file>" >&2
        echo "  Unpack:         $0 --unpack <archive file> [--include pattern] [--exclude pattern] [--include-regex pattern] [--exclude-regex pattern] [--outdir dir]" >&2
        echo "  Verify:         $0 --verify <archive file>" >&2
        echo "  Version:        $0 --version" >&2
        exit 1
        ;;
esac

exit 0
