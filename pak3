#!/bin/bash
# pak3 v3.1.0 - Enhanced with regex extraction filtering
# Usage: pak3 [dirs/files] [options]
# Example: pak3 . -t py md -c2 -m 8000 -o project.pak

VERSION="3.1.0"
SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
PAK_CORE_PY="$SCRIPT_DIR/pak_core.py"

# Defaults - much simpler now
COMPRESSION_LEVEL="none"
MAX_TOKENS=0
OUTPUT_FILE=""
INCLUDE_EXTENSIONS=()
TARGETS=()
QUIET=false
COMMAND="pack"
EXTRACT_PATTERN=""

usage() {
    cat << EOF
pak3 v$VERSION - Concise LLM-optimized file archiver with regex filtering

USAGE:
  pak3 [targets] [options]                    # Pack (default)
  pak3 -l archive.pak                        # List contents  
  pak3 -x archive.pak [-d outdir] [-p regex] # Extract (with optional pattern filter)
  pak3 -v archive.pak                        # Verify

TARGETS:
  .                    Current directory
  src/ lib/            Specific directories  
  main.py readme.md    Specific files

PACK OPTIONS:
  -t ext1,ext2         Extensions (py,md,js,ts,cpp,h,go,rs,java)
  -c LEVEL             Compression: 0=none, 1=light, 2=medium, 3=aggressive, s=smart
  -m NUM               Max tokens (0=unlimited)
  -o FILE              Output file (default: stdout or auto-generated)
  -q                   Quiet mode

EXTRACT OPTIONS:
  -p PATTERN           Extract only files matching regex pattern (applied to filename)
  -d DIR               Extract to specific directory

QUICK EXAMPLES:
  pak3 . -t py,md -c2                         # Medium compression, Python+Markdown
  pak3 src/ -cs -m 8000 -o project.pak       # Smart mode, 8k token limit
  pak3 . -t js,ts,css -c3 -q                 # Aggressive, frontend files, quiet
  pak3 main.py utils/ -c1 -o core.pak        # Light compression, specific targets

EXTRACTION EXAMPLES:
  pak3 -x project.pak                         # Extract all files
  pak3 -x project.pak -d ./extracted         # Extract to specific dir
  pak3 -x project.pak -p "test_.*"           # Extract only test files
  pak3 -x project.pak -p ".*\\.py$"          # Extract only Python files
  pak3 -x project.pak -p "(main|config)"     # Extract main or config files
  pak3 -x project.pak -p "src/.*api.*"       # Extract API-related files from src

OTHER:
  pak3 -l project.pak                         # List contents
  pak3 -v project.pak                         # Verify integrity
  pak3 -h                                     # This help

REGEX PATTERN NOTES:
  - Applied to the full file path (e.g., "src/utils/helper.py")
  - Use standard regex syntax: .* = any chars, \\. = literal dot, $ = end of string
  - Case sensitive by default
  - Examples: "test_.*\\.py$" = test Python files, ".*/(config|setup).*" = config/setup files

EOF
}

# Parse compression level shorthand
parse_compression() {
    case "$1" in
        0) echo "none" ;;
        1) echo "light" ;;
        2) echo "medium" ;;
        3) echo "aggressive" ;;
        s|smart) echo "smart" ;;
        none|light|medium|aggressive|smart) echo "$1" ;;
        *) echo "Error: Invalid compression level '$1'. Use 0-3 or s." >&2; exit 1 ;;
    esac
}

# Parse extensions shorthand  
parse_extensions() {
    local ext_string="$1"
    local -a exts
    
    # Split by comma or space
    IFS=',' read -ra ADDR <<< "$ext_string"
    for ext in "${ADDR[@]}"; do
        # Add leading dot if missing
        if [[ "$ext" != .* ]]; then
            ext=".$ext"
        fi
        exts+=("$ext")
    done
    
    printf '%s\n' "${exts[@]}"
}

# Auto-generate output filename
auto_output_name() {
    local base_name="archive"
    
    # Try to use directory name if packing single directory
    if [ ${#TARGETS[@]} -eq 1 ] && [ -d "${TARGETS[0]}" ]; then
        base_name=$(basename "${TARGETS[0]}")
        if [ "$base_name" = "." ]; then
            base_name=$(basename "$PWD")
        fi
    fi
    
    # Add compression suffix
    case "$COMPRESSION_LEVEL" in
        smart) base_name="${base_name}_smart" ;;
        aggressive) base_name="${base_name}_min" ;;
        medium) base_name="${base_name}_med" ;;
        light) base_name="${base_name}_light" ;;
    esac
    
    echo "${base_name}.pak"
}

# Check if Python core is available
has_python_core() {
    [ -f "$PAK_CORE_PY" ] && python3 -c "import sys; sys.path.insert(0, '$SCRIPT_DIR'); import pak_core" 2>/dev/null
}

# Delegate to Python core if available, fallback to bash
pack_files() {
    local python_args=()
    
    # Build arguments for Python core
    python_args+=("--compression-level" "$COMPRESSION_LEVEL")
    if [ "$MAX_TOKENS" -gt 0 ]; then
        python_args+=("--max-tokens" "$MAX_TOKENS")
    fi
    
    if [ ${#INCLUDE_EXTENSIONS[@]} -gt 0 ]; then
        python_args+=("--ext")
        python_args+=("${INCLUDE_EXTENSIONS[@]}")
    fi
    
    python_args+=("${TARGETS[@]}")
    
    if has_python_core; then
        if ! $QUIET; then
            echo "pak3: Using Python core for enhanced processing" >&2
        fi
        python3 -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')
from pak_core import main as pak_main
sys.argv = ['pak_core'] + '''${python_args[*]}'''.split()
pak_main()
"
    else
        if ! $QUIET; then
            echo "pak3: Python core not available, using simplified bash mode" >&2
        fi
        # Fallback to simplified bash implementation
        bash_pack_fallback "${python_args[@]}"
    fi
}

# Simplified bash fallback (basic functionality)
bash_pack_fallback() {
    local archive_id=$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c 12)
    
    echo "__PAK_ID__:${archive_id}"
    echo "# Archive created with pak v$VERSION (bash fallback)"
    echo "# Archive ID: $archive_id"
    echo "# Compression Mode: $COMPRESSION_LEVEL"
    
    local token_count=0
    
    for target in "${TARGETS[@]}"; do
        if [ -f "$target" ]; then
            if should_include_file "$target"; then
                pack_single_file "$target" "$archive_id" token_count
            fi
        elif [ -d "$target" ]; then
            while IFS= read -r -d '' file; do
                if should_include_file "$file"; then
                    pack_single_file "$file" "$archive_id" token_count
                    if [ "$MAX_TOKENS" -gt 0 ] && [ "$token_count" -ge "$MAX_TOKENS" ]; then
                        echo "pak3: Token limit reached" >&2
                        break 2
                    fi
                fi
            done < <(find "$target" -type f -print0)
        fi
    done
    
    echo "# Archive complete. Total estimated tokens: $token_count" >&2
}

should_include_file() {
    local file="$1"
    
    # Extension filter
    if [ ${#INCLUDE_EXTENSIONS[@]} -gt 0 ]; then
        local filename=$(basename "$file")
        local matches=false
        for ext in "${INCLUDE_EXTENSIONS[@]}"; do
            if [[ "$filename" == *"$ext" ]]; then
                matches=true
                break
            fi
        done
        if ! $matches; then
            return 1
        fi
    fi
    
    # Basic exclusions
    case "$file" in
        */.git/*|*/node_modules/*|*/__pycache__/*|*.pyc|*.pak) return 1 ;;
    esac
    
    return 0
}

pack_single_file() {
    local file="$1"
    local archive_id="$2"
    local -n token_count_ref=$3
    
    local size=$(stat -c%s "$file" 2>/dev/null || echo "0")
    local content=$(cat "$file")
    local lines=$(echo "$content" | wc -l)
    local tokens=$((${#content} / 4))
    
    token_count_ref=$((token_count_ref + tokens))
    
    echo "__PAK_FILE_${archive_id}_START__"
    echo "Path: $file"
    echo "Size: $size"
    echo "Lines: $lines"
    echo "Tokens: $tokens"
    echo "Method: bash-fallback"
    echo "__PAK_DATA_${archive_id}_START__"
    echo "$content"
    echo "__PAK_DATA_${archive_id}_END__"
}

# List archive contents with optional pattern filtering
list_archive() {
    local archive_file="$1"
    local pattern="$2"
    
    if [ ! -f "$archive_file" ]; then
        echo "Error: Archive file not found: $archive_file" >&2
        exit 1
    fi
    
    # Extract archive ID
    local first_line
    read -r first_line < "$archive_file"
    local archive_id="${first_line#__PAK_ID__:}"
    
    if [ -z "$archive_id" ]; then
        echo "Error: Invalid pak archive" >&2
        exit 1
    fi
    
    echo "Archive: $archive_file (ID: $archive_id)"
    if [ -n "$pattern" ]; then
        echo "Filter: $pattern"
    fi
    echo
    
    awk -v FILE_START="__PAK_FILE_${archive_id}_START__" -v PATTERN="$pattern" '
    $0 == FILE_START { in_file=1; next }
    in_file && /^Path: / { path = substr($0, 7); next }
    in_file && /^Size: / { size = substr($0, 7); next }
    in_file && /^Tokens: / { tokens = substr($0, 9); next }
    in_file && /^Method: / { method = substr($0, 9); next }
    in_file && /^__PAK_DATA_/ { 
        if (PATTERN == "" || path ~ PATTERN) {
            printf "%-50s %8s bytes %6s tokens [%s]\n", path, size, tokens, method
        }
        in_file=0; path=""; size=""; tokens=""; method=""
    }
    ' "$archive_file"
}

# Extract archive with optional pattern filtering
extract_archive() {
    local archive_file="$1"
    local outdir="${2:-.}"
    local pattern="$3"
    
    if [ ! -f "$archive_file" ]; then
        echo "Error: Archive file not found: $archive_file" >&2
        exit 1
    fi
    
    if has_python_core; then
        python3 -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')
from pak_core import extract_archive
extract_archive('$archive_file', '$outdir', pattern='$pattern')
"
    else
        echo "Error: Extraction requires Python core (pak_core.py)" >&2
        exit 1
    fi
}

# Verify archive
verify_archive() {
    local archive_file="$1"
    
    if [ ! -f "$archive_file" ]; then
        echo "Error: Archive file not found: $archive_file" >&2
        exit 1
    fi
    
    echo "Verifying: $archive_file"
    
    # Basic verification
    local first_line
    read -r first_line < "$archive_file"
    
    if [[ "$first_line" == __PAK_ID__:* ]]; then
        local archive_id="${first_line#__PAK_ID__:}"
        local file_count=$(grep -c "__PAK_FILE_${archive_id}_START__" "$archive_file")
        echo "✓ Valid pak archive (ID: $archive_id, Files: $file_count)"
    else
        echo "✗ Invalid pak archive format"
        exit 1
    fi
}

# Two-pass argument parsing for better command detection
# First pass: detect command type
TEMP_ARGS=("$@")
for arg in "${TEMP_ARGS[@]}"; do
    case "$arg" in
        -l|--list) COMMAND="list" ;;
        -x|--extract) COMMAND="extract" ;;
        -v|--verify) COMMAND="verify" ;;
    esac
done

# Main argument parsing
while [ $# -gt 0 ]; do
    case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -l|--list)
            COMMAND="list"
            shift
            ;;
        -x|--extract)
            COMMAND="extract"
            shift
            ;;
        -v|--verify)
            COMMAND="verify"
            shift
            ;;
        -d|--outdir)
            shift
            if [ $# -eq 0 ]; then
                echo "Error: -d requires directory path" >&2
                exit 1
            fi
            EXTRACT_DIR="$1"
            shift
            ;;
        -p|--pattern)
            shift
            if [ $# -eq 0 ]; then
                echo "Error: -p requires regex pattern" >&2
                exit 1
            fi
            EXTRACT_PATTERN="$1"
            shift
            ;;
        -t|--types)
            shift
            if [ $# -eq 0 ]; then
                echo "Error: -t requires extension list" >&2
                exit 1
            fi
            readarray -t INCLUDE_EXTENSIONS < <(parse_extensions "$1")
            shift
            ;;
        -c|--compression)
            shift
            if [ $# -eq 0 ]; then
                echo "Error: -c requires compression level" >&2
                exit 1
            fi
            COMPRESSION_LEVEL=$(parse_compression "$1")
            shift
            ;;
        -m|--max-tokens)
            shift
            if [ $# -eq 0 ]; then
                echo "Error: -m requires token count" >&2
                exit 1
            fi
            MAX_TOKENS="$1"
            shift
            ;;
        -o|--output)
            shift
            if [ $# -eq 0 ]; then
                echo "Error: -o requires filename" >&2
                exit 1
            fi
            OUTPUT_FILE="$1"
            shift
            ;;
        -q|--quiet)
            QUIET=true
            shift
            ;;
        -*)
            echo "Error: Unknown option $1" >&2
            usage >&2
            exit 1
            ;;
        *)
            # Handle positional arguments based on command type
            case "$COMMAND" in
                list|extract|verify)
                    if [ -z "$ARCHIVE_FILE" ]; then
                        ARCHIVE_FILE="$1"
                    else
                        echo "Error: Multiple archive files specified for $COMMAND command" >&2
                        exit 1
                    fi
                    ;;
                pack)
                    TARGETS+=("$1")
                    ;;
            esac
            shift
            ;;
    esac
done

# Execute command
case "$COMMAND" in
    pack)
        if [ ${#TARGETS[@]} -eq 0 ]; then
            TARGETS=(".")
        fi
        
        # Auto-generate output file if not specified and not using stdout
        if [ -z "$OUTPUT_FILE" ] && [ -t 1 ]; then
            OUTPUT_FILE=$(auto_output_name)
            if ! $QUIET; then
                echo "pak3: Auto-generated output: $OUTPUT_FILE" >&2
            fi
        fi
        
        if [ -n "$OUTPUT_FILE" ]; then
            pack_files > "$OUTPUT_FILE"
            if ! $QUIET; then
                echo "pak3: Created $OUTPUT_FILE ($(stat -c%s "$OUTPUT_FILE" 2>/dev/null || echo "?") bytes)" >&2
            fi
        else
            pack_files
        fi
        ;;
    list)
        if [ -z "$ARCHIVE_FILE" ]; then
            echo "Error: No archive file specified for listing" >&2
            exit 1
        fi
        list_archive "$ARCHIVE_FILE" "$EXTRACT_PATTERN"
        ;;
    extract)
        if [ -z "$ARCHIVE_FILE" ]; then
            echo "Error: No archive file specified for extraction" >&2
            exit 1
        fi
        extract_archive "$ARCHIVE_FILE" "${EXTRACT_DIR:-.}" "$EXTRACT_PATTERN"
        ;;
    verify)
        if [ -z "$ARCHIVE_FILE" ]; then
            echo "Error: No archive file specified for verification" >&2
            exit 1
        fi
        verify_archive "$ARCHIVE_FILE"
        ;;
esac